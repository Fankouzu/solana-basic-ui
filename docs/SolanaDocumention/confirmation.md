# 交易确认及过期

对于许多新开发人员来说，在构建应用程序时，与交易确认相关的问题很常见。本文旨在增进对 Solana 区块链上使用的确认机制的整体理解，包括一些推荐的最佳实践。

## 交易简要背景

在深入了解 Solana 交易确认和到期的工作原理之前，我们先简要了解以下几件事：

- 什么是交易
- 交易的生命周期
- 什么是区块哈希
- 简要了解历史证明（PoH）及其与区块哈希的关系

### 什么是交易？

交易由两个部分组成：消息和签名列表。交易消息是神奇发生的地方，从高层次来看，它由三个组成部分组成：

- 要调用的指令列表
- 要加载的帐户列表
- 最近的区块哈希



### 事务生命周期复习

以下是交易生命周期的高级视图。本文将涉及除步骤 1 和 4 之外的所有内容。

1. 创建指令列表以及指令需要读取和写入的帐户列表
2. 获取最近的区块哈希并使用它来准备交易消息
3. 模拟交易以确保其行为符合预期
4. 提示用户使用私钥对准备好的交易消息进行签名
5. 将交易发送到 RPC 节点，该节点尝试将其转发给当前的区块生产者
6. 希望区块生产者验证交易并将其提交到他们生产的区块中
7. 确认交易已包含在区块中或检测交易何时过期



### 什么是区块哈希？ 

“区块哈希”是指“插槽”的最后一个历史证明（PoH）哈希（如下所述）。由于 Solana 使用 PoH 作为可信时钟，因此交易的最近区块哈希可以被视为时间戳。

### 历史证明复习

Solana 的历史证明机制使用很长的递归 SHA-256 哈希链来构建可信时钟。

历史证明的“历史”部分含义：区块生产者将交易 ID 哈希到流中，以记录在其区块中处理了哪些交易。

PoH 哈希计算：next_hash = hash(prev_hash, hash(transaction_ids))

PoH 可以用作可信时钟，因为每个哈希必须按顺序生成。每个生成的块都包含一个块哈希和一个称为“ticks”的哈希检查点列表，以便验证器可以并行验证完整的哈希链并证明确实已经过去了一段时间。

## 交易过期

默认情况下，如果在一定时间内未提交到区块，所有 Solana 交易都会过期。绝大多数交易确认问题都与 RPC 节点和验证器如何检测和处理过期交易有关。深入了解交易过期的工作原理应该有助于您诊断大部分交易确认问题。



### 交易过期工作原理

每笔交易都包含一个“最近的区块哈希”，用作 PoH 时钟时间戳，并在该区块哈希不再“足够新”时过期。

当每个块最终确定时（即达到最大刻度高度，到达“块边界”），该块的最终哈希值将被添加到 BlockhashQueue 中，该队列最多存储 300 个最新块哈希值。在交易处理期间，Solana 验证器将检查每笔交易的最新区块哈希值是否记录在最近 151 个存储的哈希值（也称为“最大处理期限”）内。如果交易的最近区块哈希值早于此最大处理期限，则不会处理该交易。

由于当前的最大处理年龄为 150，并且队列中的块哈希的“年龄”为 0 索引，因此实际上有 151 个块哈希被认为“足够新”且可用于处理。

由于时隙（又名验证器可以生成块的时间段）配置为持续约 400 毫秒，但可能在 400 毫秒到 600 毫秒之间波动，因此给定的块哈希只能被交易使用约 60 到 90 秒，然后才会被视为过期通过运行时。

### 交易过期示例

让我们看一个简单的例子：

1. 验证者正在为当前槽主动生成新块
2. 验证器接收来自用户的交易，其中包含最近的 blockhash abcd...
3. 验证器根据 BlockhashQueue 中最近的区块哈希列表检查此区块哈希 abcd... 并发现它是在 151 个区块前创建的
4. 由于它正好是 151 个区块哈希旧的，因此该交易尚未过期并且仍然可以被处理！
5. 但是等等：在实际处理交易之前，验证器完成了下一个块的创建并将其添加到 BlockhashQueue 中。然后验证器开始为下一个时隙生成块（验证器为 4 个连续时隙生成块）
6. 验证器再次检查同一笔交易，发现它现在有 152 个区块哈希值旧，并拒绝它，因为它太旧了:(

## 为什么交易会过期？ 

实际上，这样做有一个很好的理由，它是为了帮助验证者避免处理同一笔交易两次。

防止双重处理的一种简单的暴力方法可能是根据区块链的整个交易历史记录检查每笔新交易。但是，通过让交易在短时间内过期，验证器只需要检查新交易是否属于最近处理的相对较小的交易集中。

### 其他区块链

Solana 防止双重处理的方法与其他区块链有很大不同。例如，以太坊跟踪每个交易发送者的计数器（随机数），并且只会处理使用下一个有效随机数的交易。

以太坊的方法对于验证者来说实施起来很简单，但对于用户来说可能会出现问题。许多人都遇到过这样的情况：他们的以太坊交易长时间陷入待处理状态，并且所有后来使用较高随机数值的交易都被阻止处理。

### Solana 的优势

Solana 的方法有一些优点：

1. 单个费用支付者可以同时提交多笔交易，并且允许以任何顺序进行处理。如果您同时使用多个应用程序，则可能会发生这种情况。
2. 如果交易没有提交到区块并过期，用户可以再次尝试，因为他们知道他们之前的交易将永远不会被处理。

通过不使用计数器，Solana 钱包体验可能更容易让用户理解，因为他们可以快速到达成功、失败或过期状态，并避免烦人的待处理状态。

### Solana 的缺点

当然也有一些缺点：

1. 验证者必须主动跟踪一组所有已处理的交易 ID，以防止重复处理。
2. 如果过期时间太短，用户可能无法在过期前提交交易。

这些缺点凸显了如何配置交易到期的权衡。如果交易的过期时间增加，验证器需要使用更多的内存来跟踪更多的交易。如果过期时间缩短，用户就没有足够的时间提交交易。

目前，Solana 集群要求交易使用不超过 151 个区块的区块哈希。

> 小贴士
>
> 这个[Github issue](https://github.com/solana-labs/solana/issues/23582) 包含一些计算，估计主网测试版验证器需要大约 150MB 的内存来跟踪交易。如果有必要的话，将来可以在不减少到期时间的情况下进行精简，如该问题中详细介绍的那样。



## 交易确认提示

如前所述，区块哈希在仅 151 个区块的时间段后就会过期，当在 400 毫秒的目标时间内处理时隙时，该时间段最快可以过去一分钟。

考虑到客户端需要获取最近的区块哈希，等待用户签名，并最终希望广播的交易到达愿意接受它的领导者，一分钟并不是很多时间。让我们了解一些技巧，以帮助避免由于交易过期而导致确认失败！

### 获取具有适当承诺级别的块哈希

鉴于到期时间很短，客户端和应用程序必须帮助用户使用尽可能新的区块哈希创建交易。

获取区块哈希时，当前推荐的 RPC API 称为 getLatestBlockhash。默认情况下，该 API 使用最终确定的承诺级别来返回最近最终确定的区块的区块哈希值。但是，您可以通过将承诺参数设置为不同的承诺级别来覆盖此行为。

**推荐**

已确认的承诺级别几乎应该始终用于 RPC 请求，因为它通常仅落后于已处理的承诺几个槽，并且属于丢弃分叉的可能性非常低。

但请随意考虑其他选择：

- 选择“已处理”将使您能够获取与其他承诺级别相比的最新区块哈希，因此可以为您提供最多的时间来准备和处理交易。但由于 Solana 区块链中分叉的普遍存在，大约 5% 的区块最终没有被集群最终确定，因此您的交易很有可能使用属于已丢弃分叉的区块哈希。使用区块哈希作为废弃区块的交易永远不会被最终区块链中的任何区块视为最近的交易。
- 使用最终确定的默认承诺级别将消除您选择的区块哈希属于已删除分叉的任何风险。权衡是，最近确认的区块和最近最终确定的区块之间通常至少存在 32 个时隙的差异。这种权衡相当严重，并且有效地将事务的过期时间减少了大约 13 秒，但在不稳定的集群条件下，这个时间可能会更长。

### 使用适当的预检承诺级别

如果您的交易使用从一个 RPC 节点获取的区块哈希，然后您使用不同的 RPC 节点发送或模拟该交易，则可能会因一个节点落后于另一个节点而遇到问题。

当 RPC 节点收到 sendTransaction 请求时，它们将尝试使用最新完成的块或使用 preflightCommitment 参数选择的块来确定事务的过期块。一个非常常见的问题是，收到的交易的区块哈希是在用于计算该交易到期的区块之后生成的。如果 RPC 节点无法确定您的交易何时过期，它只会转发您的交易一次，然后会删除该交易。

同样，当RPC节点收到simulateTransaction请求时，它们将使用最新完成的块或使用preflightCommitment参数选择的块来模拟您的交易。如果选择用于模拟的块比用于交易的块哈希的块旧，则模拟将失败并出现可怕的“未找到块哈希”错误。

**推荐**

即使您使用skipPreflight，也始终将 preflightCommitment 参数设置为与用于为 sendTransaction 和simulateTransaction 请求获取交易的块哈希值相同的承诺级别。

### 发送交易时要警惕落后的 RPC 节点 

当您的应用程序使用 RPC 池服务或当创建事务和发送事务时 RPC 端点不同时，您需要警惕一个 RPC 节点落后于另一个的情况。例如，如果您从一个 RPC 节点获取交易区块哈希，然后将该交易发送到第二个 RPC 节点进行转发或模拟，则第二个 RPC 节点可能落后于第一个节点。

**推荐**

对于 sendTransaction 请求，客户端应定期向 RPC 节点重新发送事务，这样，如果 RPC 节点稍微落后于集群，它最终会赶上并正确检测事务的过期情况。

对于simulateTransaction请求，客户端应使用replaceRecentBlockhash参数告诉RPC节点将模拟交易的blockhash替换为对模拟始终有效的blockhash。

### 避免重复使用过时的区块哈希

即使您的应用程序获取了最近的区块哈希，也请确保您不会在交易中重复使用该区块哈希太久。理想的情况是在用户签署交易之前获取最近的区块哈希。

**应用推荐**

频繁轮询最近的新区块哈希，以确保每当用户触发创建交易的操作时，您的应用程序已经有一个准备就绪的新区块哈希。

**钱包推荐**

定期轮询新的最近的区块哈希，并在签署交易之前替换交易的最近的区块哈希，以确保区块哈希尽可能新鲜。

### 获取区块哈希时使用健康的 RPC 节点 

通过从 RPC 节点获取具有已确认承诺级别的最新区块哈希，它将使用它所知道的最新已确认区块的区块哈希进行响应。 Solana 的区块传播协议会优先将区块发送到质押节点，因此 RPC 节点自然会落后于集群其他节点一个区块。他们还必须做更多的工作来处理应用程序请求，并且在用户流量大的情况下可能会滞后更多。

因此，滞后的 RPC 节点可以使用集群不久前确认的块哈希来响应 getLatestBlockhash 请求。默认情况下，落后的 RPC 节点检测到它落后于集群超过 150 个槽，将停止响应请求，但在达到该阈值之前，它们仍然可以返回即将过期的块哈希。

**推荐**

使用以下方法之一监控 RPC 节点的运行状况，以确保它们具有最新的集群状态视图：

1. 使用 getSlot RPC API 和已处理的承诺级别来获取 RPC 节点的最高已处理插槽，然后调用 getMaxShredInsertSlot RPC API 来获取 RPC 节点已收到块“碎片”的最高插槽。如果这些响应之间的差异非常大，则集群生成的块远远早于 RPC 节点处理的块。
2. 在几个不同的 RPC API 节点上调用具有已确认承诺级别的 getLatestBlockhash RPC API，并使用为其上下文槽返回最高槽的节点中的块哈希。

### 等待足够长的时间过期

**推荐**

当调用 getLatestBlockhash RPC API 获取交易的最新区块哈希时，请记下响应中的 lastValidBlockHeight。

然后，使用已确认的承诺级别轮询 getBlockHeight RPC API，直到返回的块高度大于之前返回的最后一个有效块高度。

### 考虑使用“持久”交易

有时交易过期问题确实很难避免（例如离线签名、集群不稳定）。如果前面的技巧仍然不足以满足您的用例，您可以改用持久事务（它们只需要一些设置）。

要开始使用持久交易，用户首先需要提交一个交易，该交易调用创建特殊链上“随机数”帐户并在其中存储“持久区块哈希”的指令。在未来的任何时候（只要随机数账户尚未被使用），用户都可以通过遵循以下两条规则来创建持久交易：

1. 指令列表必须以加载其链上随机数账户的“预先随机数”系统指令开始
2. 交易的区块哈希必须等于链上随机数账户存储的持久区块哈希

以下是 Solana 运行时处理这些持久事务的方式：

1. 如果交易的区块哈希不再是“最近的”，运行时会检查交易的指令列表是否以“提前随机数”系统指令开头
2. 如果是，则加载由“advance nonce”指令指定的随机数帐户
3. 然后它检查存储的持久区块哈希是否与交易的区块哈希相匹配
4. 最后，它确保将随机数帐户存储的区块哈希推进到最新的区块哈希，以确保同一交易永远不会被再次处理

有关这些持久事务如何工作的更多详细信息，您可以阅读 [original proposal](https://docs.solanalabs.com/implemented-proposals/durable-tx-nonces) 并查看 Solana 文档中的 [check out an example](https://solana.com/zh/developers/guides/advanced/introduction-to-durable-nonces) 。
